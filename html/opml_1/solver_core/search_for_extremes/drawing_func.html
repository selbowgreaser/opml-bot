<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>opml_1.solver_core.search_for_extremes.drawing_func API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>opml_1.solver_core.search_for_extremes.drawing_func</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Optional
import pandas as pd
import plotly
import plotly.graph_objects as go
import numpy as np
import sympy as sp

np.seterr(&#39;ignore&#39;)

GRID_WIDTH = 1


def draw_3d(points_of_function: pd.DataFrame,
            points_of_restriction: Optional[pd.DataFrame] = None,
            critical_points: Optional[pd.DataFrame] = None) -&gt; go.Figure:
    &#34;&#34;&#34;
    Функция рисует два графика и возвращает plotly Figure. Первый график 3-d поверхность, второй график - линии уровня.
    На первом и втором графиках рисуются точки critical_points и ограничивающая функция.

    Parameters
    ----------
    points_of_function : pd.DataFrame
        Датафрейм, у которого индексы - это значения по оси x, столбцы - значения по оси y, сами значения функции это матрица df.values.
    points_of_restriction : Optional[pd.DataFrame] = None
        Датафрейм с тремя столбцами x, y, z для ограничивающей функции
    critical_points : Optional[pd.DataFrame] = None критической точки.

    Returns
    -------
    go.Figure
        Фигуру в plotly, с двумя подграфиками.

    Examples
    --------

    &gt;&gt;&gt; import sympy as sp

    &gt;&gt;&gt; x, y = sp.symbols(&#39;x y&#39;)
    &gt;&gt;&gt; func = x ** 2 - y ** 2 / 2
    &gt;&gt;&gt; restr_func = x + y
    &gt;&gt;&gt; x_constr = (-2, 2)
    &gt;&gt;&gt; y_constr = (-2, 2)

    &gt;&gt;&gt; data = make_df_for_drawing(func, [x, y], x_conts, y_conts, 39)

    &gt;&gt;&gt; points = pd.DataFrame({&#39;x&#39;:[0, 1],
    &gt;&gt;&gt;                        &#39;y&#39;:[0, 1],
    &gt;&gt;&gt;                        &#39;z&#39;:[0, 2],
    &gt;&gt;&gt;                        &#39;types&#39;:[&#39;saddle&#39;, &#39;Пример точки&#39;],
    &gt;&gt;&gt;                        &#39;color&#39;:[&#39;yellow&#39;, &#39;red&#39;]})


    &gt;&gt;&gt; rest_points = rest_func_points(func, restr_func, [x, y], x_constr, y_constr)
    &gt;&gt;&gt; fig = draw_3d(data, rest_points, points)
    &gt;&gt;&gt; fig.show()

    # Интересная поверхность и ограничения - окружность
    &gt;&gt;&gt; x, y = sp.symbols(&#39;x y&#39;)
    &gt;&gt;&gt; func = (x + y) ** 2 + y * sp.cos(2 * x * sp.pi) + x * sp.sin(2 * y * sp.pi)
    &gt;&gt;&gt; restr_func = x ** 2  + y ** 2 - 9
    &gt;&gt;&gt; x_constr = (-5, 3.5)
    &gt;&gt;&gt; y_constr = (-4, 3)

    &gt;&gt;&gt; data = make_df_for_drawing(func, [x, y], x_constr, y_constr, 39)
    &gt;&gt;&gt; rest_points = rest_func_points(func, restr_func, [x, y], x_constr, y_constr)
    &gt;&gt;&gt; fig = draw_3d(data, rest_points)

    &gt;&gt;&gt; fig.show()
    &#34;&#34;&#34;

    if not isinstance(points_of_function, pd.DataFrame):
        raise TypeError(&#39;Массив dots не является pd.DataFrame&#39;)

    min_value = min(filter(np.isfinite, points_of_function.values.flatten()))
    max_value = max(filter(np.isfinite, points_of_function.values.flatten()))

    fig = plotly.subplots.make_subplots(rows=1, cols=2,
                                        specs=[[{&#39;is_3d&#39;: True}, {&#39;is_3d&#39;: False}]],
                                        subplot_titles=[&#39;График функции&#39;, &#39;Линии уровня&#39;])

    fig.add_trace(go.Surface(x=points_of_function.index,
                             y=points_of_function.columns,
                             z=points_of_function.values.T,
                             opacity=0.5,
                             showscale=False,
                             colorscale=&#39;ice&#39;,
                             name=&#39;f(x, y)&#39;),
                  row=1,
                  col=1)

    fig.update_scenes(xaxis_title_text=&#39;x, у.е.&#39;,
                      yaxis_title_text=&#39;y, у.е.&#39;,
                      zaxis_title_text=&#39;z, у.е.&#39;)

    fig.update_xaxes(title=&#39;x, у.е.&#39;, col=2, row=1, gridwidth=GRID_WIDTH, gridcolor=&#39;black&#39;,
                     zerolinecolor=&#39;black&#39;, zerolinewidth=GRID_WIDTH)
    fig.update_yaxes(title=&#39;y, у.е.&#39;, col=2, row=1, gridwidth=GRID_WIDTH, gridcolor=&#39;black&#39;,
                     zerolinecolor=&#39;black&#39;, zerolinewidth=GRID_WIDTH)

    fig.add_trace(go.Contour(x=points_of_function.index,
                             y=points_of_function.columns,
                             z=points_of_function.values.T,
                             opacity=0.75,
                             contours={
                                 &#39;start&#39;: min_value,
                                 &#39;end&#39;: max_value,
                                 &#39;size&#39;: (max_value - min_value) // 15,
                             },
                             colorscale=&#39;ice&#39;,
                             name=&#39;f(x, y)&#39;),
                  row=1,
                  col=2)

    if critical_points is not None and len(critical_points) &gt; 0:

        for type_point, points_of_function in critical_points.groupby(&#39;types&#39;):
            fig.add_scatter3d(x=points_of_function.x,
                              y=points_of_function.y,
                              z=points_of_function.z,
                              mode=&#39;markers&#39;,
                              marker=dict(size=6, color=points_of_function.color),
                              showlegend=True,
                              name=type_point
                              )

            fig.add_scatter(x=points_of_function.x,
                            y=points_of_function.y,
                            customdata=points_of_function.z,
                            hovertemplate=&#39;x: %{x}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;&#39; +
                                          &#39;y: %{y}&lt;br&gt;&#39; +
                                          &#39;z: %{customdata}&lt;br&gt;&#39;,
                            mode=&#39;markers&#39;,
                            marker=dict(size=10, color=points_of_function.color),
                            showlegend=False,
                            name=type_point
                            )

    fig.update_layout(legend=dict(yanchor=&#34;top&#34;,
                                  y=1,
                                  xanchor=&#34;left&#34;,
                                  x=-0.2
                                  ))

    if isinstance(points_of_restriction, pd.DataFrame):
        line3d = go.Scatter3d(x=points_of_restriction.x,
                              y=points_of_restriction.y,
                              z=points_of_restriction.z,
                              mode=&#39;lines&#39;,
                              line={&#39;width&#39;: 3, &#39;color&#39;: &#39;darkblue&#39;},
                              name=&#39;g(x, y) 3d&#39;)
        fig.add_trace(line3d, row=1, col=1)

        line = go.Scatter(x=points_of_restriction.x,
                          y=points_of_restriction.y,
                          customdata=points_of_restriction.z.round(7),
                          hovertemplate=&#39;x: %{x}&lt;br&gt;&#39; +
                                        &#39;y: %{y}&lt;br&gt;&#39; +
                                        &#39;z: %{customdata}&lt;extra&gt;&lt;/extra&gt;&#39;,
                          mode=&#39;lines&#39;,
                          line={&#39;width&#39;: 2, &#39;color&#39;: &#39;darkblue&#39;},
                          name=&#39;g(x, y)&#39;)

        fig.add_trace(line, row=1, col=2)

    return fig


def make_df_for_drawing(func,
                        variables,
                        x_constraints: tuple,
                        y_constraints: tuple,
                        cnt_points: int = 49) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Создает данные для отрисовки основной функции. Можно передать передать функцию как функцию, зависимую от двух
    аргументов или как sympy выражение. Если вы передаете sympy выражение, то обязательно передайте variables

    :param func: Функция, которую нужно отрисовать
    :param variables: список и кортеж переменных в функции func
    :param x_constraints: ограничения по оси x
    :param y_constraints: ограничения по оси y
    :param cnt_points: количество точек на каждой оси. Всего получиться cnt_points ** 2 точек.

    :return: Датафрейм с точками для отрисовки в draw_3d.
    Code examples::

        import sympy as sp

        x, y = sp.symbols(&#39;x y&#39;)
        func = x ** 2 - y ** 2 / 2
        restr_func = x + y

        data = make_df_for_drawing(func, [x, y], (-2, 2), (-2, 2), 39)
    &#34;&#34;&#34;

    func = sp.lambdify(variables, func)

    x_axis = np.linspace(x_constraints[0], x_constraints[1], cnt_points)
    y_axis = np.linspace(y_constraints[0], y_constraints[1], cnt_points)

    points = pd.DataFrame(index=x_axis,
                          columns=y_axis)

    x_axis = list(x_axis)
    y_axis = list(y_axis)

    for x_i in x_axis:
        for y_i in y_axis:
            f = func(x_i, y_i)
            if np.isfinite(f):
                points.loc[x_i, y_i] = f
            else:
                points.loc[x_i, y_i] = np.nan

    return points


def save_fig_to_pic(fig: go.Figure, path: str, extensions: list) -&gt; None:
    &#34;&#34;&#34;
    Сохраняет график в нужных форматах

    :param fig: какой plotly график нужно сохранить
    :param path: путь с названием файла для сохранения без расширения
    :param extensions: список расширений
    :return: None

    Code examples::

        save_fig_to_pic(fig, &#39;plot_3d&#39;, [&#39;png&#39;, &#39;jpeg&#39;, &#39;html&#39;])

    &#34;&#34;&#34;

    if &#39;html&#39; in extensions:
        print(&#39;Сохранение html&#39;)
        fig.write_html(path + &#39;.html&#39;, default_width=1336, default_height=668)
        extensions.remove(&#39;html&#39;)

    for extension in extensions:
        fig.write_image(path + &#39;.&#39; + extension, width=2048, height=1024, )


def rest_func_points(func,
                     restr_func,
                     variables,
                     x_const: tuple,
                     y_const: tuple,
                     cnt_points: int = 40) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Создает данные для отрисовки ограничивающей функции
    ФУНКЦИИ ДОЛЖНЫ БЫТЬ sympy выражениями

    Code examples::

        import sympy as sp
        x, y = sp.symbols(&#39;x y&#39;)
        func = x ** 2 - y ** 2 / 2
        restr_func = x + y
        rest_points = rest_func_points(func, restr_func, [x, y], (-2, 2), (-2, 2))

    :param func: Функция, поверхность, которой построена
    :param restr_func: Ограничивающая функция
    :param variables: Список с переменными
    :param x_const: Ограничения по оси x
    :param y_const: Ограничения по оси y
    :param cnt_points: Количество точек на каждой оси. АККУРАТНО, долго будет работать код на больших значениях
    :return: pd.DataFrame с точками для отрисовки. Столбцы x, y, z


    &#34;&#34;&#34;

    real_variables = sp.symbols(&#39;x y&#39;, real=True)
    func = func.subs(dict(zip(variables, real_variables)))
    restr_func = restr_func.subs(dict(zip(variables, real_variables)))
    epsilon_x = (x_const[1] - x_const[0]) / cnt_points
    epsilon_y = (y_const[1] - y_const[0]) / cnt_points

    x, y = real_variables

    out_df = pd.DataFrame(columns=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])

    i = 0
    for y_i in np.linspace(y_const[0], y_const[1], cnt_points):
        try:
            x_solve = sp.solve(restr_func.subs({y: y_i}), [x])
        except NotImplementedError:
            try:
                x_solve = [sp.nsolve(restr_func.subs({y: y_i}), x, x_const[0])]
            except ValueError:
                x_solve = []

        for x_i in x_solve:
            x_i = float(x_i)
            if x_const[0] &lt;= x_i &lt;= x_const[1]:
                try:
                    f = float(func.subs({x: x_i, y: y_i}))
                    out_df.loc[i] = [x_i, y_i, f]
                    i += 1
                except TypeError:
                    pass

    for x_i in np.linspace(x_const[0], x_const[1], cnt_points):
        try:
            y_solve = sp.solve(restr_func.subs({x: x_i}), [y])
        except NotImplementedError:
            try:
                y_solve = [sp.nsolve(restr_func.subs({x: x_i}), [y], y_const[0])]
            except ValueError:
                y_solve = []

        for y_i in y_solve:
            y_i = float(y_i)
            if y_const[0] &lt;= y_i &lt;= y_const[1]:
                try:
                    f = float(func.subs({x: x_i, y: y_i}))
                    out_df.loc[i] = [x_i, y_i, f]
                    i += 1
                except TypeError:
                    pass

    if out_df.shape[0] &gt; 0:
        out_df = out_df.sort_values(&#39;x&#39;).reset_index(drop=True)

        len_ways = pd.DataFrame(index=out_df.index,
                                columns=out_df.index)

        for i, dot1 in enumerate(out_df[[&#39;x&#39;, &#39;y&#39;]].apply(tuple, axis=1)):
            for j, dot2 in enumerate(out_df[[&#39;x&#39;, &#39;y&#39;]].apply(tuple, axis=1)):
                if i == j:
                    len_ways.iloc[i, j] = np.inf
                else:
                    len_ways.iloc[i, j] = (dot1[0] - dot2[0]) ** 2 + (dot1[1] - dot2[1]) ** 2

        len_ways = len_ways.astype(float)
        way = [0]
        for i in range(len_ways.shape[0] - 1):
            source = way[-1]
            target, length = len_ways.loc[source].idxmin(), len_ways.loc[source].min()
            len_ways.loc[source] = np.inf
            len_ways.loc[:, source] = np.inf
            if length &gt; (epsilon_x + epsilon_y):
                break
            way.append(target)

        if check_dot_in_round(out_df.loc[way[0], [&#39;x&#39;, &#39;y&#39;]].values,
                              out_df.loc[way[-1], [&#39;x&#39;, &#39;y&#39;]].values,
                              epsilon_x,
                              epsilon_y):
            way.append(0)

        return out_df.loc[way]
    return out_df.iloc[:0]


def check_dot_in_round(center, check_point, radius_x, radius_y) -&gt; bool:
    &#34;&#34;&#34;
    Вспомогательная функция для rest_func_points
    Проверяет, входит ли точка check_point в малую окрестность точки center
    :param center: Основная точка, окрестность которой рассматриваем
    :param check_point: Точка, которую проверяем
    :param radius_x: значение по оси x
    :param radius_y: значение по оси y
    :return: False - точка не входит, True - точка входит
    &#34;&#34;&#34;
    flag_x = False
    if center[0] - radius_x &lt;= check_point[0] &lt;= center[0] + radius_x:
        flag_x = True

    flag_y = False
    if center[1] - radius_y &lt;= check_point[1] &lt;= center[1] + radius_y:
        flag_y = True

    return flag_x * flag_y</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="opml_1.solver_core.search_for_extremes.drawing_func.check_dot_in_round"><code class="name flex">
<span>def <span class="ident">check_dot_in_round</span></span>(<span>center, check_point, radius_x, radius_y) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Вспомогательная функция для rest_func_points
Проверяет, входит ли точка check_point в малую окрестность точки center
:param center: Основная точка, окрестность которой рассматриваем
:param check_point: Точка, которую проверяем
:param radius_x: значение по оси x
:param radius_y: значение по оси y
:return: False - точка не входит, True - точка входит</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_dot_in_round(center, check_point, radius_x, radius_y) -&gt; bool:
    &#34;&#34;&#34;
    Вспомогательная функция для rest_func_points
    Проверяет, входит ли точка check_point в малую окрестность точки center
    :param center: Основная точка, окрестность которой рассматриваем
    :param check_point: Точка, которую проверяем
    :param radius_x: значение по оси x
    :param radius_y: значение по оси y
    :return: False - точка не входит, True - точка входит
    &#34;&#34;&#34;
    flag_x = False
    if center[0] - radius_x &lt;= check_point[0] &lt;= center[0] + radius_x:
        flag_x = True

    flag_y = False
    if center[1] - radius_y &lt;= check_point[1] &lt;= center[1] + radius_y:
        flag_y = True

    return flag_x * flag_y</code></pre>
</details>
</dd>
<dt id="opml_1.solver_core.search_for_extremes.drawing_func.draw_3d"><code class="name flex">
<span>def <span class="ident">draw_3d</span></span>(<span>points_of_function: pandas.core.frame.DataFrame, points_of_restriction: Optional[pandas.core.frame.DataFrame] = None, critical_points: Optional[pandas.core.frame.DataFrame] = None) ‑> plotly.graph_objs._figure.Figure</span>
</code></dt>
<dd>
<div class="desc"><p>Функция рисует два графика и возвращает plotly Figure. Первый график 3-d поверхность, второй график - линии уровня.
На первом и втором графиках рисуются точки critical_points и ограничивающая функция.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points_of_function</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Датафрейм, у которого индексы - это значения по оси x, столбцы - значения по оси y, сами значения функции это матрица df.values.</dd>
<dt><strong><code>points_of_restriction</code></strong> :&ensp;<code>Optional[pd.DataFrame] = None</code></dt>
<dd>Датафрейм с тремя столбцами x, y, z для ограничивающей функции</dd>
</dl>
<p>critical_points : Optional[pd.DataFrame] = None критической точки.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>go.Figure</code></dt>
<dd>Фигуру в plotly, с двумя подграфиками.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import sympy as sp
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; x, y = sp.symbols('x y')
&gt;&gt;&gt; func = x ** 2 - y ** 2 / 2
&gt;&gt;&gt; restr_func = x + y
&gt;&gt;&gt; x_constr = (-2, 2)
&gt;&gt;&gt; y_constr = (-2, 2)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; data = make_df_for_drawing(func, [x, y], x_conts, y_conts, 39)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; points = pd.DataFrame({'x':[0, 1],
&gt;&gt;&gt;                        'y':[0, 1],
&gt;&gt;&gt;                        'z':[0, 2],
&gt;&gt;&gt;                        'types':['saddle', 'Пример точки'],
&gt;&gt;&gt;                        'color':['yellow', 'red']})
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; rest_points = rest_func_points(func, restr_func, [x, y], x_constr, y_constr)
&gt;&gt;&gt; fig = draw_3d(data, rest_points, points)
&gt;&gt;&gt; fig.show()
</code></pre>
<h1 id="-">Интересная поверхность и ограничения - окружность</h1>
<pre><code class="language-python-repl">&gt;&gt;&gt; x, y = sp.symbols('x y')
&gt;&gt;&gt; func = (x + y) ** 2 + y * sp.cos(2 * x * sp.pi) + x * sp.sin(2 * y * sp.pi)
&gt;&gt;&gt; restr_func = x ** 2  + y ** 2 - 9
&gt;&gt;&gt; x_constr = (-5, 3.5)
&gt;&gt;&gt; y_constr = (-4, 3)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; data = make_df_for_drawing(func, [x, y], x_constr, y_constr, 39)
&gt;&gt;&gt; rest_points = rest_func_points(func, restr_func, [x, y], x_constr, y_constr)
&gt;&gt;&gt; fig = draw_3d(data, rest_points)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; fig.show()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_3d(points_of_function: pd.DataFrame,
            points_of_restriction: Optional[pd.DataFrame] = None,
            critical_points: Optional[pd.DataFrame] = None) -&gt; go.Figure:
    &#34;&#34;&#34;
    Функция рисует два графика и возвращает plotly Figure. Первый график 3-d поверхность, второй график - линии уровня.
    На первом и втором графиках рисуются точки critical_points и ограничивающая функция.

    Parameters
    ----------
    points_of_function : pd.DataFrame
        Датафрейм, у которого индексы - это значения по оси x, столбцы - значения по оси y, сами значения функции это матрица df.values.
    points_of_restriction : Optional[pd.DataFrame] = None
        Датафрейм с тремя столбцами x, y, z для ограничивающей функции
    critical_points : Optional[pd.DataFrame] = None критической точки.

    Returns
    -------
    go.Figure
        Фигуру в plotly, с двумя подграфиками.

    Examples
    --------

    &gt;&gt;&gt; import sympy as sp

    &gt;&gt;&gt; x, y = sp.symbols(&#39;x y&#39;)
    &gt;&gt;&gt; func = x ** 2 - y ** 2 / 2
    &gt;&gt;&gt; restr_func = x + y
    &gt;&gt;&gt; x_constr = (-2, 2)
    &gt;&gt;&gt; y_constr = (-2, 2)

    &gt;&gt;&gt; data = make_df_for_drawing(func, [x, y], x_conts, y_conts, 39)

    &gt;&gt;&gt; points = pd.DataFrame({&#39;x&#39;:[0, 1],
    &gt;&gt;&gt;                        &#39;y&#39;:[0, 1],
    &gt;&gt;&gt;                        &#39;z&#39;:[0, 2],
    &gt;&gt;&gt;                        &#39;types&#39;:[&#39;saddle&#39;, &#39;Пример точки&#39;],
    &gt;&gt;&gt;                        &#39;color&#39;:[&#39;yellow&#39;, &#39;red&#39;]})


    &gt;&gt;&gt; rest_points = rest_func_points(func, restr_func, [x, y], x_constr, y_constr)
    &gt;&gt;&gt; fig = draw_3d(data, rest_points, points)
    &gt;&gt;&gt; fig.show()

    # Интересная поверхность и ограничения - окружность
    &gt;&gt;&gt; x, y = sp.symbols(&#39;x y&#39;)
    &gt;&gt;&gt; func = (x + y) ** 2 + y * sp.cos(2 * x * sp.pi) + x * sp.sin(2 * y * sp.pi)
    &gt;&gt;&gt; restr_func = x ** 2  + y ** 2 - 9
    &gt;&gt;&gt; x_constr = (-5, 3.5)
    &gt;&gt;&gt; y_constr = (-4, 3)

    &gt;&gt;&gt; data = make_df_for_drawing(func, [x, y], x_constr, y_constr, 39)
    &gt;&gt;&gt; rest_points = rest_func_points(func, restr_func, [x, y], x_constr, y_constr)
    &gt;&gt;&gt; fig = draw_3d(data, rest_points)

    &gt;&gt;&gt; fig.show()
    &#34;&#34;&#34;

    if not isinstance(points_of_function, pd.DataFrame):
        raise TypeError(&#39;Массив dots не является pd.DataFrame&#39;)

    min_value = min(filter(np.isfinite, points_of_function.values.flatten()))
    max_value = max(filter(np.isfinite, points_of_function.values.flatten()))

    fig = plotly.subplots.make_subplots(rows=1, cols=2,
                                        specs=[[{&#39;is_3d&#39;: True}, {&#39;is_3d&#39;: False}]],
                                        subplot_titles=[&#39;График функции&#39;, &#39;Линии уровня&#39;])

    fig.add_trace(go.Surface(x=points_of_function.index,
                             y=points_of_function.columns,
                             z=points_of_function.values.T,
                             opacity=0.5,
                             showscale=False,
                             colorscale=&#39;ice&#39;,
                             name=&#39;f(x, y)&#39;),
                  row=1,
                  col=1)

    fig.update_scenes(xaxis_title_text=&#39;x, у.е.&#39;,
                      yaxis_title_text=&#39;y, у.е.&#39;,
                      zaxis_title_text=&#39;z, у.е.&#39;)

    fig.update_xaxes(title=&#39;x, у.е.&#39;, col=2, row=1, gridwidth=GRID_WIDTH, gridcolor=&#39;black&#39;,
                     zerolinecolor=&#39;black&#39;, zerolinewidth=GRID_WIDTH)
    fig.update_yaxes(title=&#39;y, у.е.&#39;, col=2, row=1, gridwidth=GRID_WIDTH, gridcolor=&#39;black&#39;,
                     zerolinecolor=&#39;black&#39;, zerolinewidth=GRID_WIDTH)

    fig.add_trace(go.Contour(x=points_of_function.index,
                             y=points_of_function.columns,
                             z=points_of_function.values.T,
                             opacity=0.75,
                             contours={
                                 &#39;start&#39;: min_value,
                                 &#39;end&#39;: max_value,
                                 &#39;size&#39;: (max_value - min_value) // 15,
                             },
                             colorscale=&#39;ice&#39;,
                             name=&#39;f(x, y)&#39;),
                  row=1,
                  col=2)

    if critical_points is not None and len(critical_points) &gt; 0:

        for type_point, points_of_function in critical_points.groupby(&#39;types&#39;):
            fig.add_scatter3d(x=points_of_function.x,
                              y=points_of_function.y,
                              z=points_of_function.z,
                              mode=&#39;markers&#39;,
                              marker=dict(size=6, color=points_of_function.color),
                              showlegend=True,
                              name=type_point
                              )

            fig.add_scatter(x=points_of_function.x,
                            y=points_of_function.y,
                            customdata=points_of_function.z,
                            hovertemplate=&#39;x: %{x}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;&#39; +
                                          &#39;y: %{y}&lt;br&gt;&#39; +
                                          &#39;z: %{customdata}&lt;br&gt;&#39;,
                            mode=&#39;markers&#39;,
                            marker=dict(size=10, color=points_of_function.color),
                            showlegend=False,
                            name=type_point
                            )

    fig.update_layout(legend=dict(yanchor=&#34;top&#34;,
                                  y=1,
                                  xanchor=&#34;left&#34;,
                                  x=-0.2
                                  ))

    if isinstance(points_of_restriction, pd.DataFrame):
        line3d = go.Scatter3d(x=points_of_restriction.x,
                              y=points_of_restriction.y,
                              z=points_of_restriction.z,
                              mode=&#39;lines&#39;,
                              line={&#39;width&#39;: 3, &#39;color&#39;: &#39;darkblue&#39;},
                              name=&#39;g(x, y) 3d&#39;)
        fig.add_trace(line3d, row=1, col=1)

        line = go.Scatter(x=points_of_restriction.x,
                          y=points_of_restriction.y,
                          customdata=points_of_restriction.z.round(7),
                          hovertemplate=&#39;x: %{x}&lt;br&gt;&#39; +
                                        &#39;y: %{y}&lt;br&gt;&#39; +
                                        &#39;z: %{customdata}&lt;extra&gt;&lt;/extra&gt;&#39;,
                          mode=&#39;lines&#39;,
                          line={&#39;width&#39;: 2, &#39;color&#39;: &#39;darkblue&#39;},
                          name=&#39;g(x, y)&#39;)

        fig.add_trace(line, row=1, col=2)

    return fig</code></pre>
</details>
</dd>
<dt id="opml_1.solver_core.search_for_extremes.drawing_func.make_df_for_drawing"><code class="name flex">
<span>def <span class="ident">make_df_for_drawing</span></span>(<span>func, variables, x_constraints: tuple, y_constraints: tuple, cnt_points: int = 49) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Создает данные для отрисовки основной функции. Можно передать передать функцию как функцию, зависимую от двух
аргументов или как sympy выражение. Если вы передаете sympy выражение, то обязательно передайте variables</p>
<p>:param func: Функция, которую нужно отрисовать
:param variables: список и кортеж переменных в функции func
:param x_constraints: ограничения по оси x
:param y_constraints: ограничения по оси y
:param cnt_points: количество точек на каждой оси. Всего получиться cnt_points ** 2 точек.</p>
<p>:return: Датафрейм с точками для отрисовки в draw_3d.
Code examples::</p>
<pre><code>import sympy as sp

x, y = sp.symbols('x y')
func = x ** 2 - y ** 2 / 2
restr_func = x + y

data = make_df_for_drawing(func, [x, y], (-2, 2), (-2, 2), 39)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_df_for_drawing(func,
                        variables,
                        x_constraints: tuple,
                        y_constraints: tuple,
                        cnt_points: int = 49) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Создает данные для отрисовки основной функции. Можно передать передать функцию как функцию, зависимую от двух
    аргументов или как sympy выражение. Если вы передаете sympy выражение, то обязательно передайте variables

    :param func: Функция, которую нужно отрисовать
    :param variables: список и кортеж переменных в функции func
    :param x_constraints: ограничения по оси x
    :param y_constraints: ограничения по оси y
    :param cnt_points: количество точек на каждой оси. Всего получиться cnt_points ** 2 точек.

    :return: Датафрейм с точками для отрисовки в draw_3d.
    Code examples::

        import sympy as sp

        x, y = sp.symbols(&#39;x y&#39;)
        func = x ** 2 - y ** 2 / 2
        restr_func = x + y

        data = make_df_for_drawing(func, [x, y], (-2, 2), (-2, 2), 39)
    &#34;&#34;&#34;

    func = sp.lambdify(variables, func)

    x_axis = np.linspace(x_constraints[0], x_constraints[1], cnt_points)
    y_axis = np.linspace(y_constraints[0], y_constraints[1], cnt_points)

    points = pd.DataFrame(index=x_axis,
                          columns=y_axis)

    x_axis = list(x_axis)
    y_axis = list(y_axis)

    for x_i in x_axis:
        for y_i in y_axis:
            f = func(x_i, y_i)
            if np.isfinite(f):
                points.loc[x_i, y_i] = f
            else:
                points.loc[x_i, y_i] = np.nan

    return points</code></pre>
</details>
</dd>
<dt id="opml_1.solver_core.search_for_extremes.drawing_func.rest_func_points"><code class="name flex">
<span>def <span class="ident">rest_func_points</span></span>(<span>func, restr_func, variables, x_const: tuple, y_const: tuple, cnt_points: int = 40) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Создает данные для отрисовки ограничивающей функции
ФУНКЦИИ ДОЛЖНЫ БЫТЬ sympy выражениями</p>
<p>Code examples::</p>
<pre><code>import sympy as sp
x, y = sp.symbols('x y')
func = x ** 2 - y ** 2 / 2
restr_func = x + y
rest_points = rest_func_points(func, restr_func, [x, y], (-2, 2), (-2, 2))
</code></pre>
<p>:param func: Функция, поверхность, которой построена
:param restr_func: Ограничивающая функция
:param variables: Список с переменными
:param x_const: Ограничения по оси x
:param y_const: Ограничения по оси y
:param cnt_points: Количество точек на каждой оси. АККУРАТНО, долго будет работать код на больших значениях
:return: pd.DataFrame с точками для отрисовки. Столбцы x, y, z</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rest_func_points(func,
                     restr_func,
                     variables,
                     x_const: tuple,
                     y_const: tuple,
                     cnt_points: int = 40) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Создает данные для отрисовки ограничивающей функции
    ФУНКЦИИ ДОЛЖНЫ БЫТЬ sympy выражениями

    Code examples::

        import sympy as sp
        x, y = sp.symbols(&#39;x y&#39;)
        func = x ** 2 - y ** 2 / 2
        restr_func = x + y
        rest_points = rest_func_points(func, restr_func, [x, y], (-2, 2), (-2, 2))

    :param func: Функция, поверхность, которой построена
    :param restr_func: Ограничивающая функция
    :param variables: Список с переменными
    :param x_const: Ограничения по оси x
    :param y_const: Ограничения по оси y
    :param cnt_points: Количество точек на каждой оси. АККУРАТНО, долго будет работать код на больших значениях
    :return: pd.DataFrame с точками для отрисовки. Столбцы x, y, z


    &#34;&#34;&#34;

    real_variables = sp.symbols(&#39;x y&#39;, real=True)
    func = func.subs(dict(zip(variables, real_variables)))
    restr_func = restr_func.subs(dict(zip(variables, real_variables)))
    epsilon_x = (x_const[1] - x_const[0]) / cnt_points
    epsilon_y = (y_const[1] - y_const[0]) / cnt_points

    x, y = real_variables

    out_df = pd.DataFrame(columns=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])

    i = 0
    for y_i in np.linspace(y_const[0], y_const[1], cnt_points):
        try:
            x_solve = sp.solve(restr_func.subs({y: y_i}), [x])
        except NotImplementedError:
            try:
                x_solve = [sp.nsolve(restr_func.subs({y: y_i}), x, x_const[0])]
            except ValueError:
                x_solve = []

        for x_i in x_solve:
            x_i = float(x_i)
            if x_const[0] &lt;= x_i &lt;= x_const[1]:
                try:
                    f = float(func.subs({x: x_i, y: y_i}))
                    out_df.loc[i] = [x_i, y_i, f]
                    i += 1
                except TypeError:
                    pass

    for x_i in np.linspace(x_const[0], x_const[1], cnt_points):
        try:
            y_solve = sp.solve(restr_func.subs({x: x_i}), [y])
        except NotImplementedError:
            try:
                y_solve = [sp.nsolve(restr_func.subs({x: x_i}), [y], y_const[0])]
            except ValueError:
                y_solve = []

        for y_i in y_solve:
            y_i = float(y_i)
            if y_const[0] &lt;= y_i &lt;= y_const[1]:
                try:
                    f = float(func.subs({x: x_i, y: y_i}))
                    out_df.loc[i] = [x_i, y_i, f]
                    i += 1
                except TypeError:
                    pass

    if out_df.shape[0] &gt; 0:
        out_df = out_df.sort_values(&#39;x&#39;).reset_index(drop=True)

        len_ways = pd.DataFrame(index=out_df.index,
                                columns=out_df.index)

        for i, dot1 in enumerate(out_df[[&#39;x&#39;, &#39;y&#39;]].apply(tuple, axis=1)):
            for j, dot2 in enumerate(out_df[[&#39;x&#39;, &#39;y&#39;]].apply(tuple, axis=1)):
                if i == j:
                    len_ways.iloc[i, j] = np.inf
                else:
                    len_ways.iloc[i, j] = (dot1[0] - dot2[0]) ** 2 + (dot1[1] - dot2[1]) ** 2

        len_ways = len_ways.astype(float)
        way = [0]
        for i in range(len_ways.shape[0] - 1):
            source = way[-1]
            target, length = len_ways.loc[source].idxmin(), len_ways.loc[source].min()
            len_ways.loc[source] = np.inf
            len_ways.loc[:, source] = np.inf
            if length &gt; (epsilon_x + epsilon_y):
                break
            way.append(target)

        if check_dot_in_round(out_df.loc[way[0], [&#39;x&#39;, &#39;y&#39;]].values,
                              out_df.loc[way[-1], [&#39;x&#39;, &#39;y&#39;]].values,
                              epsilon_x,
                              epsilon_y):
            way.append(0)

        return out_df.loc[way]
    return out_df.iloc[:0]</code></pre>
</details>
</dd>
<dt id="opml_1.solver_core.search_for_extremes.drawing_func.save_fig_to_pic"><code class="name flex">
<span>def <span class="ident">save_fig_to_pic</span></span>(<span>fig: plotly.graph_objs._figure.Figure, path: str, extensions: list) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Сохраняет график в нужных форматах</p>
<p>:param fig: какой plotly график нужно сохранить
:param path: путь с названием файла для сохранения без расширения
:param extensions: список расширений
:return: None</p>
<p>Code examples::</p>
<pre><code>save_fig_to_pic(fig, 'plot_3d', ['png', 'jpeg', 'html'])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_fig_to_pic(fig: go.Figure, path: str, extensions: list) -&gt; None:
    &#34;&#34;&#34;
    Сохраняет график в нужных форматах

    :param fig: какой plotly график нужно сохранить
    :param path: путь с названием файла для сохранения без расширения
    :param extensions: список расширений
    :return: None

    Code examples::

        save_fig_to_pic(fig, &#39;plot_3d&#39;, [&#39;png&#39;, &#39;jpeg&#39;, &#39;html&#39;])

    &#34;&#34;&#34;

    if &#39;html&#39; in extensions:
        print(&#39;Сохранение html&#39;)
        fig.write_html(path + &#39;.html&#39;, default_width=1336, default_height=668)
        extensions.remove(&#39;html&#39;)

    for extension in extensions:
        fig.write_image(path + &#39;.&#39; + extension, width=2048, height=1024, )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="opml_1.solver_core.search_for_extremes" href="index.html">opml_1.solver_core.search_for_extremes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="opml_1.solver_core.search_for_extremes.drawing_func.check_dot_in_round" href="#opml_1.solver_core.search_for_extremes.drawing_func.check_dot_in_round">check_dot_in_round</a></code></li>
<li><code><a title="opml_1.solver_core.search_for_extremes.drawing_func.draw_3d" href="#opml_1.solver_core.search_for_extremes.drawing_func.draw_3d">draw_3d</a></code></li>
<li><code><a title="opml_1.solver_core.search_for_extremes.drawing_func.make_df_for_drawing" href="#opml_1.solver_core.search_for_extremes.drawing_func.make_df_for_drawing">make_df_for_drawing</a></code></li>
<li><code><a title="opml_1.solver_core.search_for_extremes.drawing_func.rest_func_points" href="#opml_1.solver_core.search_for_extremes.drawing_func.rest_func_points">rest_func_points</a></code></li>
<li><code><a title="opml_1.solver_core.search_for_extremes.drawing_func.save_fig_to_pic" href="#opml_1.solver_core.search_for_extremes.drawing_func.save_fig_to_pic">save_fig_to_pic</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>